##### 0729

###### 需求：

写一个监测脚本，检测本机所有的磁盘分区是否都读写正常

可以遍历所有挂载点，然后新建一个测试文件，再删除测试文件，如果可以正常新建和删除，那说明该分区没问题

###### 脚本

```bash
#!/bin/bash

for mount_p in `df |sed '1d' |grep -v 'tmpfs' |awk '{print $NF}'`
do
    ## 创建测试文件，并删除，从而确定该磁盘分区是否有问题
    touch $mount_p/testfile  &&  rm -f $mount_p/testfile
    if [ $? -ne 0 ]
    then
        echo "$mount_p 读写有问题"
    else
        echo "$mount_p 读写正常"
    fi
done
```

 df |sed '1d' |grep -v 'tmpfs' |awk '{print $NF} 的最终结果

如果系统中有多个非`tmpfs`文件系统（如`/`, `/home`, `/boot`），输出可能是：

/
/home
/boot

这条命令的用途是**快速获取所有持久化存储（非临时文件系统）的挂载目录列表**，常用于脚本中检查磁盘使用情况的场景。

$? 是 **Shell 中的特殊变量**，表示**上一条命令的退出状态码**

- **0**：表示上一条命令**执行成功**。

- **非 0**：表示上一条命令**执行失败**，具体数字代表不同的错误类型（由命令或程序自定义）

  ```bash
  ls /etc/passwd
  echo $?    # 输出 0，因为 ls 成功找到了文件
  
  ls /nonexistent
  echo $?    # 输出 2（或 1，取决于系统），因为目录不存在
  ```

  注意

  - `$?` 的值**只在下一条命令执行前有效**，因为每条命令都会覆盖它









###### 关键总结：

###### 1.sed命令（知识点多，后续完善）

sed '1d' 表示删除第一行（即表头），保留数据行



###### 2.grep命令

grep -v "tmpfs" 表示过滤掉包含`tmpfs`的行（即排除基于内存的临时文件系统）





###### 3.awk命令

`awk '{print $NF}'`打印每行的最后一列（`$NF`表示最后一列），即文件系统的**挂载路径**：





###### 4.Linux的连接符号

**&& 逻辑与**：

*a && b* 表示首先执行命令 *a*，如果 *a* 执行成功，则执行命令 *b*。如果 *a* 执行失败，则不会执行 *b*

```bash
# 只有在创建目录成功后才进入该目录
mkdir mydir && cd mydir
```



**& 并行执行**：

*a & b* 表示首先执行命令 *a*，然后执行命令 *b*，无论 *a* 是否成功，*b* 都会执行。这种连接符用于并行执行多个命令。

```bash
# 同时执行两个命令
ls & pwd
```



**|| 逻辑或**:

*a || b* 表示首先执行命令 *a*，如果 *a* 执行成功，则不会执行命令 *b*。如果 *a* 执行失败，则执行命令 *b*。这种连接符常用于在前一个命令失败时执行备用命令。

```bash
# 如果目录不存在则创建目录
cd mydir || mkdir mydir
```

**| 管道符**:

*a | b* 表示将命令 *a* 的输出作为命令 *b* 的输入，无论 *a* 是否成功，都会执行 *b*。这种连接符常用于将一个命令的输出传递给另一个命令进行处理。例如：

```bash
# 将 ls 的输出传递给 grep 进行过滤
ls | grep *.txt
```

**; 分号**:

*;* 表示顺序执行多个命令，无论前一个命令是否成功，都会执行下一个命令。例如：

```bash
# 顺序执行三个命令
echo "Hello"; echo "World"; echo "!"
```

